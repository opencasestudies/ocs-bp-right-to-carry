---
title: "Open Case Studies: Examination of Multicollinearity Influence on Inference Using Right-to-Carry Gun Law and Violent Crime Data"
author: "Michael Ontiveros, Carrie Wright, PhD."
css: style.css
output:
  html_document:
    self_contained: yes
    code_download: yes
    highlight: tango
    number_sections: no
    theme: cosmo
    toc: yes
    toc_float: yes
  pdf_document:
    toc: yes
  word_document:
    toc: yes
---

<style>
#TOC {
  background: url("https://opencasestudies.github.io/img/logo.jpg");
  background-size: contain;
  padding-top: 240px !important;
  background-repeat: no-repeat;
}
</style>


---


```{r setup, include=FALSE}
knitr::opts_chunk$set(include = TRUE, comment = NA, echo = TRUE,
                      message = FALSE, warning = FALSE, cache = FALSE, fig.width=10, fig.height=7,
                      fig.align = "center", out.width = '90%')
library(here)
library(knitr)
```

#### {.outline }
```{r, echo = FALSE, out.width = "800 px"}
knitr::include_graphics(here::here("img", "mainplot.png"))
```

####

## {.disclaimer_block}

**Disclaimer**: The purpose of the [Open Case Studies](https://opencasestudies.github.io){target="_blank"} project is **to demonstrate the use of various data science methods, tools, and software in the context of messy, real-world data**. A given case study does not cover all aspects of the research process, is not claiming to be the most appropriate way to analyze a given data set, and should not be used in the context of making policy decisions without external consultation from scientific experts. 

## {.liscence_block}

This work is licensed under the Creative Commons Attribution-NonCommercial 3.0 [(CC BY-NC 3.0)](https://creativecommons.org/licenses/by-nc/3.0/us/){target="_blank"}  United States License.

# **Motivation**
*** 

This case study will introduce the topic of multicolinearity. We will do so by showcasing a real world example where multicolinearity in part resulted in historically contriversial and conflicting findings about the influence of the adoption of right-to-carry (RTC) concealed handgun laws on violent crime rates in the United States. 

We will focus on two articles:

1) The first analysis by [Lott and Mustard](https://chicagounbound.uchicago.edu/cgi/viewcontent.cgi?article=1150&context=law_and_economics){target="_blank"} published in 1996 suggests that RTC laws reduce violent crime. Lott authored a book extending these findings in 1998 called [***More Guns, Less Crime***](https://en.wikipedia.org/wiki/More_Guns,_Less_Crime){target="_blank"}.

```{r, echo=FALSE, out.height = '100%', out.width = '100%', fig.align='center'}
knitr::include_graphics(here("img", "Lott.png"))
```

2) The second analysis is a recent article by [Donohue, et al.](https://www.nber.org/papers/w23510.pdf){target="_blank"} published in 2017 that suggests that RTC laws increase violent crime. Donohue has also published previous articles with titles such as [***"Shooting down the "More Guns, Less Crime" Hypothesis***](https://www.jstor.org/stable/1229603?seq=1){target="_blank"} 

```{r, echo=FALSE, out.height = '100%', out.width = '100%', fig.align='center'}
knitr::include_graphics(here("img", "Donohue.png"))
```

This has been a controversial topic as many other articles also had conflicting results. See [here](https://en.wikipedia.org/wiki/More_Guns,_Less_Crime){target="_blank"} for a list of studies.

The [Donohue, et al.](https://www.nber.org/papers/w23510.pdf){target="_blank"} article discusses how there are many other important methodolical aspects besides multicolinearity that could account for the historically conflicting results in these previous papers.

In fact, nearly every aspect of the data analysis process was different between the [Donohue, et al.](https://www.nber.org/papers/w23510.pdf){target="_blank"} analysis and the [Lott and Mustard](https://chicagounbound.uchicago.edu/cgi/viewcontent.cgi?article=1150&context=law_and_economics){target="_blank"} analysis.

```{r, echo=FALSE, out.height = '75%', out.width = '75%', fig.align='center'}
knitr::include_graphics(here("img", "Educational_Graphic1.jpg"))
```

However, we will focus particularly on multicolinearity and we will explore how it can influence linear regression analyses and result in different conclusions. 

This analysis will demonstrate how methodological details can be critically influential for our overall conclusions and can result in important policy related consequences. This [article]((https://www.nber.org/papers/w23510.pdf){target="_blank"}) will provide a basis for the motivation. 

#### {.reference_block}

John J. Donohue et al., Right‐to‐Carry Laws and Violent Crime: A Comprehensive Assessment Using Panel Data and a State‐Level Synthetic Control Analysis. *Journal of Empirical Legal Studies*, 16,2 (2019).

David B. Mustard & John Lott. Crime, Deterrence, and Right-to-Carry Concealed Handguns. *Coase-Sandor Institute for Law & Economics* Working Paper No. 41, (1996).

####


Here you can see the differences in the data used in the featured RTC articles:


```{r, echo=FALSE, out.height = '100%', out.width = '100%', fig.align='center'}
knitr::include_graphics(here("img",'Donohue_Table2.png'))
```


We will perform analyses similar to those in these articles, however **we will not try to recreate them**, instead we will simplify our analysis to allow us to focus on multicolinearity.


Therefore we will use a subset of the listed explanatory variables and they will be consistent for both analyses that we will perform, with the exception that one analysis will have 6 demographic variables like the analysis in the [Donohue, et al.](https://www.nber.org/papers/w23510.pdf){target="_blank"} article and the other will have 36 demogrpahic variables like the analysis in the [Lott and Mustard](https://chicagounbound.uchicago.edu/cgi/viewcontent.cgi?article=1150&context=law_and_economics){target="_blank"} article.


# **Main Question**
*** 

#### {.main_question_block}
<b><u> Our main question: </u></b>

1) How does the inclusion of different numbers of age groups influence the results of an analysis of right to carry laws and violence rates?

####


# **Learning Objectives** 
*** 

<u>**Statistical Learning Objectives:**</u> 

In this case study, students will learn:  
1) what multicolinearity is and how it can influence linear regression coefficients  
2) how to look for the presence of multicolinarity  
3) the difference between multicolinearity and correlation  

<u>**Data science Learning Objectives:**</u>

1) joining data from multiple sources (dplyr)  
2) reshaping data into different formats (tidyr)  
2) visualizations (ggplot2)  


We will especially focus on using packages and functions from the [`Tidyverse`](https://www.tidyverse.org/){target="_blank"}, such as `dplyr` and `ggplot2`. The tidyverse is a library of packages created by RStudio. While some students may be familiar with previous R programming packages, these packages make data science in R especially efficient.


```{r, out.width = "20%", echo = FALSE, fig.align ="center"}
include_graphics("https://tidyverse.tidyverse.org/logo.png")
```

# **Context**
***

So what exactly is a **right-to-carry law**?

It is a law thatspecifies if and how citizens are allowed to have a firearm on their person or nearby (for example in the citizen's car) in public. 

The [Second Amendment](https://en.wikipedia.org/wiki/Second_Amendment_to_the_United_States_Constitution){target="_blank"} to the United States Constitution guarantees the right to "keep and bear arms". The amendment was ratified in 1791 as part of the [Bill of Rights](https://en.wikipedia.org/wiki/United_States_Bill_of_Rights){target="_blank"}.

```{r, echo=FALSE, out.height = '50%', out.width = '50%', fig.align='center'}
knitr::include_graphics("https://upload.wikimedia.org/wikipedia/commons/7/79/Bill_of_Rights_Pg1of1_AC.jpg")
```

However, there are no federal laws about carrying firearms in public. 

These laws are created and enforced at the state level. Sates vary greatly in their laws about the right to carry firearms. Some require extensive effort to obtain a permit to legally carry a firearm, while other states require very minimal effort to legally carry a firearm.


According to Wikipedia about the history of right-to-carry policies in the United States:

> Public perception on concealed carry vs open carry has largely flipped. In the early days of the United States, open carrying of firearms, long guns and revolvers was a common and well-accepted practice. Seeing guns carried openly was not considered to be any cause for alarm. Therefore, anyone who would carry a firearm but attempt to conceal it was considered to have something to hide, and presumed to be a criminal. For this reason, concealed carry was denounced as a detestable practice in the early days of the United States.

> Concealed weapons bans were passed in Kentucky and Louisiana in 1813. (In those days open carry of weapons for self-defense was considered acceptable; concealed carry was denounced as the practice of criminals.) By 1859, Indiana, Tennessee, Virginia, Alabama, and Ohio had followed suit. By the end of the nineteenth century, similar laws were passed in places such as Texas, Florida, and Oklahoma, which protected some gun rights in their state constitutions. Before the mid 1900s, most U.S. states had passed concealed carry laws rather than banning weapons completely. Until the late 1990s, many Southern states were either "No-Issue" or "Restrictive May-Issue". Since then, these states have largely enacted "Shall-Issue" licensing laws, with numerous states legalizing "Unrestricted concealed carry".

See [here](https://en.wikipedia.org/wiki/History_of_concealed_carry_in_the_U.S.){target="_blank"} for more information.

Here are the general categories of Right to Carry Laws:

```{r, echo=FALSE, out.height = '100%', out.width = '100%', fig.align='center'}
knitr::include_graphics(here("img", "RTC.png"))
```
[source](https://www.nraila.org/gun-laws/){target="_blank"}


```{r, echo=FALSE, out.height = '100%', out.width = '100%', fig.align='center'}
knitr::include_graphics(here("img", "RTC_map.png"))
```

[source](https://www.nraila.org/gun-laws/){target="_blank"}

You can see that none of the fifty states have no-issue laws currently, meaning that all states allow the right to carry firearms at least in some way, however the level of restrictions is dramatically different from one state to another.

Here you can see how these laws have changed over time around the country:
```{r, echo=FALSE, out.height = '100%', out.width = '100%', fig.align='center'}
knitr::include_graphics("https://upload.wikimedia.org/wikipedia/commons/thumb/5/5a/Right_to_Carry%2C_timeline.gif/620px-Right_to_Carry%2C_timeline.gif")
```

There is variation from state to state even within the same general category:

For example here are the [current carry laws in Idaho](https://www.nraila.org/gun-laws/state-gun-laws/idaho/) which is considered an "Unrestricted - no permit required" state:

>Idaho permits the open carrying of firearms.

>Idaho law permits both residents and non-residents who are at least 18 years old to carry concealed weapons, without a carry license, outside the limits of or confines of any city, provided the person is not otherwise disqualified from being issued a license to carry.

>A person may also carry concealed weapons on or about his or her person, without a license, in the person’s own place of abode or fixed place of business, on property in which the person has any ownership or leasehold interest, or on private property where the person has permission to carry from any person who has an ownership or leasehold interest in that property. 

>State law also allows any resident of Idaho or a current member of the armed forces of the United States to carry a concealed handgun without a license to carry, provided the person is over 18 years old and not disqualified from being issued a license to carry concealed weapons under state law. An amendment to state law that takes effect on July 1, 2020 changes the reference in the above law from “a resident of Idaho” to “any citizen of the United States.”  


And here are the [current carry laws in Arizona](https://www.nraila.org/gun-laws/state-gun-laws/arizona/) which is also considered an "Unrestricted- - no permit required" state:

> Arizona respects the right of law abiding citizens to openly carry a handgun.

> Any person 21 years of age or older, who is not prohibited possessor, may carry a weapon openly or concealed without the need for a license. Any person carrying without a license must acknowledge and comply with the demands of a law enforcement officer when asked if he/she is carrying a concealed deadly weapon, if the officer has initiated an "investigation" such as a traffic stop.

Notice that citizens in Idaho only need to be 18 to carry a firearm, whereas they must be 21 in Arizona. 


In contrast here is an example of [current carry laws in Maryland](https://www.nraila.org/gun-laws/state-gun-laws/maryland/) which is considered a "Rights Restricted-Very Limited Issue" state:

>Carrying and Transportation in Vehicles
It is unlawful for any person without a permit to wear or carry a handgun, openly or concealed, upon or about his person.  It is also unlawful for any person to knowingly transport a handgun in any vehicle traveling on public roads, highways, waterways or airways, or upon roads or parking lots generally used by the public. This does not apply to any person wearing, carrying or transporting a handgun within the confines of real estate owned or leased by him, or on which he resides, or within the confines of a business establishment owned or leased by him.

>Permit To Carry
Application for a permit to carry a handgun is made to the Secretary of State Police.  In addition to the printed application form, the applicant should submit a notarized letter stating the reasons why he is applying for a permit.


avocado....Right to carry and covid masks?

# **Limitations**
*** 
There are some important considerations regarding this data analysis to keep in mind: 

1) We do not use all of the data used by either the  [Lott and Mustard](https://chicagounbound.uchicago.edu/cgi/viewcontent.cgi?article=1150&context=law_and_economics){target="_blank"} or [Donohue, et al.](https://www.nber.org/papers/w23510.pdf){target="_blank"} analyses, nor do we perform the same analysis of each article. We instead perform a much simpler analysis with less variables for the purposes of illustration of the concept of multicollinearity and its influence on regression coefficients, not to reproduce either analysis.

2) Because our analysis is an oversimplification, our analysis should not be used for determining policy changes, instead we suggest that users consult with a specialist.


We would also like to note that...AVOCADO
It is important that we do not treat race as an objective measure. Despite this, it can be used to advance scientific inquiry. For more information on this topic, we have included a link to a [paper on the use of race as a measure in epidemiology](https://academic.oup.com/epirev/article/22/2/187/456942). 


We will begin by loading the packages that we will need:

```{r}
library(here)
library(readxl)
library(readr)
library(pdftools)
library(dplyr)
library(magrittr)
library(tidyr)
library(stringr)
library(purrr)
library(forcats)

library(car) # vif function
library(plm) # fixed effect model, linear regression
library(broom) # tidy output
library(tidyverse) # general wrangling functions
library(cowplot) # to produce plot of plots 
library(GGally)
library(ggrepel)
library(scales)
library(latex2exp)
library(viridis)
library(ggcorrplot)
library(rsample)

set.seed(999)
```


 Package   | Use                                                                         
---------- |-------------
[here](https://github.com/jennybc/here_here){target="_blank"}       | to easily load and save data
[readr](https://readr.tidyverse.org/){target="_blank"}      | to import the CSV file data
[car]  | to calculate vif values
[purrr] | to combine multiple tibbles within a list of tibbles
[forcats] | to collapse levels of factors into more summarised versions
The first time we use a function, we will use the `::` to indicate which package we are using. Unless we have overlapping function names, this is not necessary, but we will include it here to be informative about where the functions we will use come from.


# **What are the data?**
***

Below is a table from the [Donohue, et al.](https://www.nber.org/papers/w23510.pdf){target="_blank"} paper that shows the data used in both analyses, where DAW stands for [Donohue, et al.](https://www.nber.org/papers/w23510.pdf){target="_blank"} and LM stands for [Lott and Mustard](https://chicagounbound.uchicago.edu/cgi/viewcontent.cgi?article=1150&context=law_and_economics){target="_blank"}.


```{r, echo=FALSE, out.height = '100%', out.width = '100%', fig.align='center'}
knitr::include_graphics(here("img", "Donohue_AppendixJ.png"))
```

We will be using a subset of these variables, which are highlighted in green:


```{r, echo=FALSE, out.height = '100%', out.width = '100%', fig.align='center'}
knitr::include_graphics(here("img", "ourdata.png"))
```


# **Data Import**
***



## Demographic and opulation data

To obtain information about age, sex, and race, and overall population we will use US Census Bureau data, just like both of the articles. The cesnus data is available for different time spans. Here are the links for the years used in our analysis. We will use data from 1977 to 2010.

Data   | Link                                                                        
---------- |-------------
**years 1977 to 1979**  | [link](https://www2.census.gov/programs-surveys/popest/tables/1900-1980/state/asrh/)  
**years 1980 to 1989**  | [link](https://www2.census.gov/programs-surveys/popest/tables/1980-1990/counties/asrh/) * county data was used for this decade which also has state information
**years 1990 to 1999**  | [link](https://www2.census.gov/programs-surveys/popest/tables/1990-2000/state/asrh/)
**years 2000 to 2010**  | [link](https://www.census.gov/data/datasets/time-series/demo/popest/intercensal-2000-2010-state.html) <br> [technical documentation](https://www2.census.gov/programs-surveys/popest/technical-documentation/file-layouts/2000-2010/intercensal/state/st-est00int-alldata.pdf){target="_blank"}

To import the data we will use the `read_csv()` function of the `readr` package for the csv files. In some decades, there are separate files for each year, we will read each of these together using the base `list.files()` function to get all of the names for each file and then the `map()` function of the `purrr` package to apply the `read_csv()` function on all of the file paths in the list created by `list.files()`. For years that are txt files we will use `read_table2()` also fo the `readr` package. The `read_table2()` function, unlike the `read_table()`,  allows for any number of whitespace characters between columns, and the lines can be of different lengths.

AVOCADO I am a bit confused about the last decade... it's only one file but it seems to need map...

```{r}

dem_77_79 <- read_csv("docs/Demographics/Decade_1970/pe-19.csv", skip = 5)

dem_80_89 <- list.files(recursive = TRUE,
                  path = "docs/Demographics/Decade_1980/",
                  pattern = "*.csv",
                  full.names = TRUE) %>% 
  map(~read_csv(., skip=5))

dem_90_99 <- list.files(recursive = TRUE,
                  path = "docs/Demographics/Decade_1990/",
                  pattern = "*.txt",
                  full.names = TRUE) %>% 
  map(~read_table2(., skip = 14))


dem_00_10_2 <- read_csv("docs/Demographics/Decade_2000/st-est00int-alldata.csv")

dem_00_10 <- list.files(recursive = TRUE,
                  path = "docs/Demographics/Decade_2000/",
                  pattern = "*.csv",
                   full.names = TRUE) %>% 
   map(~read_csv(.))

head(dem_00_10)

```

Notice that the `STATE` variable for the demographic data is numeric. That is because it is encoded by [Federal Information Processing Standard (FIPS) state codes](https://en.wikipedia.org/wiki/Federal_Information_Processing_Standard_state_code){target="_blank". Thus we also need to import data  about FIPS encoding so that we can identify what data corresponds to what state.


## State FIPS codes

The following data was downloaded from the [US Census Bureau](https://www.census.gov/geographies/reference-files/2014/demo/popest/2014-geocodes-state.html){target="_blank"}.

To import the data we will use the `read_xls()` function of the `readxl` package. Since the first five lines of this excel is information about the source of the data and when it was released, we need to skip importing these lines using the `skip` argument so that the data has the same number of columns for each row. 

```{r, out.width = "500 px"}
knitr::include_graphics(here("img", "FIPS.png"))

```

```{r}
STATE_FIPS <- read_xls("docs/State_FIPS_codes/state-geocodes-v2014.xls", skip = 5)
(STATE_FIPS)
```

## Police staffing data
The following data was downloaded from the [Federal Bureau of Investigation](https://crime-data-explorer.fr.cloud.gov/downloads-and-docs). 


The `read_csv()` function of the `readr` package guesses what the class is for each variable, but sometimes it makes mistakes. It is good to specify the class for variables if you know them. We know that we want the variables about male and female counts to be numeric. We can specify that using the `col_types =` argument. See [here](https://readr.tidyverse.org/articles/readr.html) and [here](https://cran.r-project.org/web/packages/readr/vignettes/readr.html) for more information.

```{r}
ps_data <- read_csv("docs/Police_staffing/pe_1960_2018.csv")
ps_data <- read_csv("docs/Police_staffing/pe_1960_2018.csv",
                    col_types = cols(male_total_ct = "n",
                                     female_total_ct = "n"))

ps_data <- read_csv("docs/Police_staffing/pe_1960_2018.csv",
                   col_types =  cols(male_total_ct = col_double(),
                                   female_total_ct = col_double()))
head(ps_data)                            
```



## Unemplyment data

The following data was downloaded from the [U.S. Bureau of Labor Statistics](https://data.bls.gov/cgi-bin/dsrv?la). 

There are excel files for each state.  As you can see, there are many rows to skip to make sure that there are the same number of columns for each row. We can also see that the state name is located in a couple of the first rows. 

```{r}
knitr::include_graphics(here("img", "Unemp.png"))
```

We can also see that here if we just try to read in the files directly.

```{r}

ue_rate_data <- list.files(recursive = TRUE,
                  path = "docs/Unemployment",
                  pattern = "*.xlsx",
                  full.names = TRUE) %>% 
  map(~read_xlsx(.))
      
head(ue_rate_data)[1]
```

So now we will skip the first 10 lines. And also create a names tibble that contains only the cell with the state information.

```{r}
 
 ue_rate_data <- list.files(recursive = TRUE,
                  path = "docs/Unemployment",
                  pattern = "*.xlsx",
                  full.names = TRUE) %>% 
  map(~read_xlsx(., skip = 10))
  
head(ue_rate_data[1])
```

To get the state name for each file using the `map()` function to perform functions across all of the files, we will specifically import only a small range of cells using the `range = ` argument and then grab the cell that has state information based on it's location within the range of cells imported using `c()` and then use the base `unlist()` function to unlist the list that this creates.

```{r}
ue_rate_names <- list.files(recursive = TRUE,
                  path = "docs/Unemployment",
                  pattern = "*.xlsx",
                  full.names = TRUE) %>%
  map(~read_xlsx(., range = "B4:B6")) %>%
  map(., c(1,2)) %>%
  unlist()

ue_rate_names
```

Now we will make these values the names of the different tibbles within `ue_rate_data`.
```{r}
names(ue_rate_data) <- ue_rate_names
```

## Poverty data
Extracted from Table 21 from [US Census Bureau Poverty Data ](https://www.census.gov/data/tables/time-series/demo/income-poverty/historical-poverty-people.html)

AVOCado strange issue

```{r}

#**persistent warning from unknown origin** https://community.rstudio.com/t/persistent-unknown-or-uninitialised-column-warnings/64879

#solution to above is alledgedly: "In any case the suggested approach is to initialize the column"


poverty_rate_data <- read_xls("docs/Poverty/hstpov21.xls", skip=2) #This may cause initialization issue, not easily reproducible (even after restarting R)

head(poverty_rate_data)
```

We can see that this will require some wranlging to make the data more usable. 

## Violent crime

Violent crime data was obtained from [here](https://www.ucrdatatool.gov/Search/Crime/State/StatebyState.cfm) This data is a bit trickier because of spaces and `/` in the column names, thus the `read_lines()` function of the `readr` package works better than the `read_csv()` function.


```{r}
knitr::include_graphics(here("img", "crime.png"))
```

```{r}
crime_data <- read_lines("docs/Crime/CrimeStatebyState.csv", skip = 2, skip_empty_rows = TRUE)
head(crime_data)

```

We can see that this data will also require some wranlging to make it more usable. 

## Right-to-carry data

This data is extracted from table in [Donohue paper](https://www.nber.org/papers/w23510.pdf) {target="_blank"}. We will use the function `pdf_text()`  of the `pdftools` package to import the pdf document.

```{r}

if(!file.exists(here("docs", "w23510.pdf"))){
  url <- "https://www.nber.org/papers/w23510.pdf"
  utils::download.file(url, here("docs", "w23510.pdf"))
}

DAWpaper <- pdf_text(here("docs", "w23510.pdf"))

head(DAWpaper[1])

```

Again, this data will also require quite a bit of wrangling.



# **Data Wrangling**
***
## State FIPS codes

Let's first take a look at our state FIPS data to see if it needs any cleaning or reshaping. We should start with this data, becuase we will need to use it to wrangle some of the other data.

```{r}
head(STATE_FIPS)
```

We only need the last two columns, but we might want to rename them. The `Name` variable is vague. The variable with the FIPS code is called `State\n(FIPS)`. To get rid of the new line in this variable name and to change the `Name` variable to something more informative, we will use the `rename()` function of the `dplyr` package.  To use this function, we need to list the new name first followed by `=` and then the existing variable. We can rename multiple variables at the same time by using a comma to separate the variables we are renaming. We will use the `select()` function also of the `dplyr` package just to keep these variables, and we will filter out the rows with FIPS values of `00` with the `filter()` function, agian also part of the `dplyr` package. we will specify that we want `STATEFP` values that are not equal to `00` by using this operator: `!=`. We will also use the double pipe operator `%<>%` of the `magrittr` package which allows us to use data as iuput and then reassign it after we peform sum functions using it.

```{r}

STATE_FIPS %<>% 
dplyr::rename( STATEFP = `State\n(FIPS)`,
                 STATE = Name) %>%
    dplyr::select(STATEFP, STATE) %>%
    dplyr::filter(STATEFP != "00")

STATE_FIPS

```

## Demographic and population data

<details> <summary> Click here to see detailed information about how the demogrphic data was wrangled </summary>


<font size="6"> **1977-1979**</font>

***


Now let's take a look at our demographic data across the decades that we wish to study. If you have very wide data (meaning it has many columns), one way to view the data so that you can see all of the columns at the same time is to use the `glimpse()` function of the `dplyr` package. 

Taking a look at the first decade of data, we can see that the `Race/Sex Indicator` contains two types of data, the race and the sex. This does not follow the tidy data philosophy, where each cell of a tibble should only contain one piece of information. Typically one might think of using the `separate()` function of the `tidyr` package to split this variable into two. However, one of the race values is `Other races` and since this also has a space, this makes separating this data more tricky.

Instead we will use the `str_extract()` function of the `stringr` package and the `mutate()` function of the `dplyr` package. The "mutate()" will allow us to create new variables, and "str_extract()" function  will allow us to match specific patterns and pull out matches to those patterns. Therefore, if the `Race/Sex Indicator` value is `Other races male` and if we extract patterns matching either `"male"` or `"female"` which we can specify like this `pattern = "male|female"` then, the value will be `male`.

First we need to rename the `Race/Sex Indicator` varaible to not have spaces so that it is compatible with the `str_extract()` function.

We also want to rename a couple of variables to be simpler and filter the data to only include the years of the data we are interested in, as well as remove some variables that we dont need like the `FIPS State Code`. We can remove variables by using the `select()` function with a `-` minus sign in front of the variable we wish to remove.

```{r}
dplyr::glimpse(dem_77_79)


dem_77_79 <- dem_77_79 %>%
  rename("race_sex" =`Race/Sex Indicator`) %>%
  mutate(SEX = str_extract(race_sex, "male|female"),
        RACE = str_extract(race_sex, "Black|White|Other"))%>%
  select(-`FIPS State Code`, -`race_sex`) %>%
  rename("YEAR" = `Year of Estimate`,
        "STATE" = `State Name`) %>%
  filter(YEAR %in% 1977:1979)

glimpse(dem_77_79)
```

That's looking pretty  good! We also want to take all the age group variabels and make one variable that is the age group name and one that is the value of the population count for that age group. To do this we will use the `pivot_longer()` function of the `tidyr` package. To use this function, we need to use the `cols` argument to indicate which columns we want to pivot. We also name the new variables we will create with the `names_to` and `values_to` arguments. The `names_to` will be the name of the variable that will identify each age group and `values_to` will be the name of the variable that contains the corresponding population values.
```{r}
dem_77_79 <- dem_77_79 %>%
  pivot_longer(cols=contains("years"),
               names_to = "AGE_GROUP",
               values_to = "SUB_POP")

glimpse(dem_77_79)
```

We also want to get data about the total population for the state for each year.

To do so we can sum all the values for the `SUB_POP` variable that we just created. To do this we can use the `group_by` and `summarise()` functions of the `dplyr` package. The `group_by()` function specifies how we want to calculate  our sum, that we would like to calculate it for each year and each state individually. Thus, all the values that have the same `STATE` and `YEAR` values will be summed together, rather than summing using all of the values in the `SUB_POP` variable. The `.groups` argument allows us to remove the grouping after we peform the calculation with `summarise()`.

```{r}
pop_77_79 <- dem_77_79 %>%
  group_by(YEAR, STATE) %>%
  summarise("TOT_POP" = sum(SUB_POP), .groups = "drop") 

pop_77_79 
```


 Now we will add the population value to the demographic tibble using the `left_join()` function of the `dplyr` package. It is imporant that we specify how this should be done, that the `YEAR` and `STATE` variable vlaues should match eachother. This will place the `dem_77_79` variables to the left of the `pop_77_79` data. 
 
```{r}
dem_77_79 <- dem_77_79 %>%
  left_join(pop_77_79, by = c("YEAR","STATE"))

dem_77_79
```

We will also calculate the percentage that each group makes up of the total population, by dividing the `SUB_POP` by the `TOT_POP` and multiplying by 100 using the `mutate()` function. we will also remove the other population variables.

```{r}
dem_77_79 %<>%
  mutate(PERC_SUB_POP = (SUB_POP/TOT_POP)*100) %>%
  select(-SUB_POP, -TOT_POP)

dem_77_79
```
It is important to make sure that we have the total values we would expect. We have two levels of `SEX`, three levels of `Race`, three levels of `YEAR`, eighteen levels of `AGE_GROUP`, and fifty one levels of `STATE`. If we multiply this together we get 16,524 which is the same as the number of rows in our final `dem_77_79` data. Looks good!

Also Let's make the values of the `SEX` variable capatalized so that they match the other values of the other variables like `RACE` etc. This will help us to keep consistent values across the different years as we wrangle the data for the other decades. To do so we will use the `str_to_title()` function of the `stringr` package. We need to use the `pull()` function to get the values of `SEX` out of `dem_77_79`. Once we make them captialized they are then reasigned to the `SEX` variable. 

```{r}

dem_77_79 %<>%
  mutate(SEX = str_to_title(pull(dem_77_79, SEX)))

# This can also be done line this:
dem_77_79 %<>%
  mutate(SEX = str_to_title(pull(., SEX)))
```

<font size="6"> **1980-1989**</font>

***


For this decade each year is a separate tibble and they are combined as a list.
```{r}
class(dem_80_89)
```

So the first thing we need to do is combine each tibble of the list together. We can do that using the `bind_rows()` function of `dplyr` which appends the data together based on the presence of columns with the same name in the different tibbles. We will use the `map_df()` function of the `purrr` package to allow us to do this across each tibble in our list. 

```{r}
dem_80_89 <- dem_80_89 %>%
  map_df(bind_rows)

glimpse(dem_80_89 )
```

Great! Now our data is all together.

Now we will wrangle the data similarly to the previous decade.
```{r}
dem_80_89 <- dem_80_89 %>%
  rename("race_sex" =`Race/Sex Indicator`) %>%
  mutate(SEX = str_extract(race_sex, "male|female"),
        RACE = str_extract(race_sex, "Black|White|Other"))%>%
  select( -`race_sex`) %>%
  rename("YEAR" = `Year of Estimate`)
         
glimpse(dem_80_89)
```
Notice that this time the state information is based on the numeric FIPS value. We want only the first two values, as the rest indicate the county. We can use the `str_sub()` function of the `stringr` package for this. We will specify that we want to start at the first position and end at the second.  Just like `str_extract()` we need to rename this variable first so that it is compatible. 
```{r}
dem_80_89 %<>%
rename("STATEFP_temp" = "FIPS State and County Codes") %>%
mutate(STATEFP = str_sub(STATEFP_temp, start = 1, end = 2)) %>%
    left_join(STATE_FIPS, by = "STATEFP") %>%
  dplyr::select(-STATEFP)

glimpse(dem_80_89)
```


```{r}
dem_80_89 %<>%
  pivot_longer(cols=contains("years"),
               names_to = "AGE_GROUP",
               values_to = "SUB_POP_temp") %>%
  group_by(YEAR, STATE, AGE_GROUP, SEX, RACE) %>%
  summarise(SUB_POP = sum(SUB_POP_temp), .groups="drop")

dem_80_89
```
  
```{r}
pop_80_89 <- dem_80_89 %>%
  group_by(YEAR, STATE) %>%
  summarise("TOT_POP" = sum(SUB_POP), .groups = "drop") 


dem_80_89 <- dem_80_89 %>%
  left_join(pop_80_89, by = c("YEAR","STATE")) %>%
  mutate(PERC_SUB_POP = (SUB_POP/TOT_POP)*100) %>%
  dplyr::select(-SUB_POP, -TOT_POP)

dem_80_89
```

Just like with the data from the 70s we will also change the values for `SEX` to be capitalized.

```{r}
dem_80_89 %<>%
  mutate(SEX = str_to_title(pull(., SEX)))
```

Again, it is important to make sure that we have the total values we would expect. This time we have: two levels of `SEX`, three levels of `Race`, ten levels of `YEAR`, eighteen levels of `AGE_GROUP`, and fifty one levels of `STATE`.

If we multiply these together we get 55,080, which is the same as the number of rows of the final `dem_80_89` data. Looks good!

<font size="6"> **1990-1999**</font>

***

Just like the 80s we need to combine the data across the files:

```{r}
dem_90_99 <- dem_90_99 %>%
  map_df(bind_rows)
```

```{r}
glimpse(dem_90_99)
```
For this decade the column names can't all be imported in a simple way from the table, so they need to be recoded.

Here is what the data looks like before importing:

```{r, echo = FALSE, out.width = "800 px"}
knitr::include_graphics(here::here("img", "90.png"))
```

So, first using the base `colnames()` function we change the names of the column names.

```{r}

colnames(dem_90_99) <- c("YEAR",
                         "STATEFP",
                         "Age",
                         "NH_W_M",
                         "NH_W_F",
                         "NH_B_M",
                         "NH_B_F",
                         "NH_AIAN_M",
                         "NH_AIAN_F",
                         "NH_API_M",
                         "NH_API_F",
                         "H_W_M",
                         "H_W_F",
                         "H_B_M",
                         "H_B_F",
                         "H_AIAN_M",
                         "H_AIAN_F",
                         "H_API_M",
                         "H_API_F")

glimpse(dem_90_99)
```

Notice also that the first row is all `NA` values from white space in the orginal table for 1990, this is probably true for each year. We can check them dimensions of our table using the base `dim()` function. When we filter for rows where `YEAR` is `NA`, we indeed see 10 rows, which is what we would expect if we have a row like this for each of the years in the decade. We see the same if we try a different variable. Now we will test to see how large our tibble is if we drop rows with `NA` values using the `drop_na()` function of `tidyr`. We that indeed our dimensions only changed by ten, so there are not other rows with missing values that we might not expect. So now we will resign the `dem_90_99` variable after removing these rows.

```{r}

dim(dem_90_99)

dem_90_99 %>%
  filter(is.na(YEAR))

dem_90_99 %>%
  filter(is.na(Age)) 

dem_90_99 %>%drop_na() 

dem_90_99 %<>%drop_na() 
```

Then we sum across the nonhispanic and hispaninc groups because this information is not available for the other previous decades. Then we will remove the variables for the hispanic and nonhispanic subgroups using `select()`.

```{r}

dem_90_99%<>%
    mutate(W_M = NH_W_M + H_W_M,
           W_F = NH_W_F + H_W_F,
           B_M = NH_B_M + H_B_M,
           B_F = NH_B_F + H_B_F,
           AIAN_M = NH_AIAN_M + H_AIAN_M,
           AIAN_F = NH_AIAN_F + H_AIAN_F,
           API_M = NH_API_M + H_API_M,
           API_F = NH_API_F + H_API_F) %>%
  select(-starts_with("NH_"), -starts_with("H_"))

glimpse(dem_90_99)
```

Looking better! We also need to add age groups like the other decades. We will take a look at the 80s data using the `distinct()` function of the `dplyr` package to see what age groups we need. We can use the base `cut()` function to create a new variable with `mutate()` called `AGE_GROUP` that will have a label for every change in 5 years of age. The `right = FALSE` argument specifies that the interval is not closed on the right, meaning that if the value is at the cutpoint like the `Age` value is 5, then it will be in the `5 to 9 years` group.

We can make the labels for the `AGE_GROUP` variable match those of `dem_77_79` but we need to pull out the values of the tibble created by `distinct()`. To do this we can use the `pull()` function from the `dplyr` package. Note that it is important to check that the `AGE_GROUP` values are listed in order for `dem_77_79`. We will also remove the `Age` variable after we create the new `AGE_GROUP` variable for the `dem_90_99` data. 


```{r}

distinct(dem_77_79, AGE_GROUP)
pull(distinct(dem_77_79, AGE_GROUP))

dem_90_99 %<>%
  mutate(AGE_GROUP = cut(Age,
                         breaks = seq(0,90, by=5),
                         right = FALSE, labels = pull(distinct(dem_77_79,AGE_GROUP), AGE_GROUP))) %>%
  select(-Age)

glimpse(dem_90_99)

```

Like the previous decades we will create a `RACE` and `SUB_POP` variable using `pivot_longer()` to create a single `Race` variable out of all the subgroup variables. 

Now we need to collapse the data for the various races so that it matches the previous decades. This time we will use the `case_when()` function of the `dplyr` package and the `str_detect()` function of the `stringr` package to identify when the race is something other than `B` or `W` and replace with the value `Other`. The value to the right of the `~` indicates what we want the value of the new variable to be if the value of the variable we are using with `str_decect()` matches the condition specified. If the value does not match the specified condition, than the other values will be what ever is listed after `TRUE ~`. We will then create population counts as we did previously for the other decades.

Finally, we will create new sums for the subpopulations where we sum across the two `Other` subgroups `Race`  to a create a single value for each value of `YEAR`, `SEX`, `AGE_GROUP`, and `STATE` by using the `group_by()` function and `summarie()`.  

```{r}
dem_90_99  %<>%
  pivot_longer(cols = c(starts_with("W_"),
                    starts_with("B_"),
                    starts_with("AIAN_"),
                    starts_with("API_")),
               names_to = "RACE",
               values_to = "SUB_POP_temp")

dem_90_99 %<>%
  mutate(SEX = case_when(str_detect(RACE, "_M") ~ "Male",
                         TRUE ~ "Female"),
         RACE = case_when(str_detect(RACE, "W_") ~ "White",
                          str_detect(RACE, "B_") ~ "Black",
                          TRUE ~ "Other")) %>%
  left_join(STATE_FIPS, by = "STATEFP") %>%
  dplyr::select(-STATEFP)

dem_90_99 %<>%
  group_by(YEAR, STATE, AGE_GROUP, SEX, RACE) %>%
  summarise(SUB_POP = sum(SUB_POP_temp), .groups="drop")

```

```{r}
pop_90_99 <- dem_90_99 %>%
  group_by(YEAR, STATE) %>%
  summarise(TOT_POP = sum(SUB_POP), .groups = "drop")

dem_90_99 <- dem_90_99 %>%
  left_join(pop_90_99, by=c("YEAR", "STATE")) %>%
  mutate(PERC_SUB_POP = (SUB_POP/TOT_POP)*100) %>%
  dplyr::select(-SUB_POP, -TOT_POP)

dem_90_99
```


Again, we should check to make sure that we have the total values we would expect. We have the same number of unique values for each of our variables as in with the data from the 80s, so if we collpased the data for the different additional subpopulations in this data, then we have done it correctly. 

Indeed it looks like we have 55,080 rows, which is what we would expect and is the same as the number of rows of the final `dem_80_89` data. Looks good!

<font size="6"> **2000-2010**</font>

***

Again, for this decade we need to combine the data across years.

```{r}
dem_00_10 <- dem_00_10 %>%
  map_df(bind_rows)

glimpse(dem_00_10)

```

Ok, the data looks a bit different from the others. First we will remove a couple of variables that we probably don't need. Also it looks like we have some values for the entire United Sates and we will drop these to be like the other decades.



```{r}
dem_00_10 %<>%
  select(-ESTIMATESBASE2000,-CENSUS2010POP) %>%
  filter(NAME != "United States")
```

We can see that there are lots of values that are zero. According to the [technical documentation](https://www2.census.gov/programs-surveys/popest/technical-documentation/file-layouts/2000-2010/intercensal/state/st-est00int-alldata.pdf){target="_blank"} for this data, zero values indicate the total for the other categories of `Sex`, `Origin`, `Race`, and `AGEGRP`.


```{r, echo = FALSE, out.width = "600 px"}
knitr::include_graphics(here::here("img", "tech_info.png"))
```

So we will drop the total values for `SEX`, `RACE`, and `AGEGRP` by removing the rows where these variables are equal to zero.

We will also want to only select for the total values for `Origin` as we do not wish to divide the data into subgroups about hispanic ethnicity because we do not have that information for the first two decades. Thus we will filter for only the rows where `Origin` is equal to zero.

We will also then remove the `REGION`, `Division`, `STATE`, and `Origin` variables. We will then rename `NAME` to be `STATE` and rename `AGEGRP` to be like the other decades as `AGE_GROUP`.

```{r}
dem_00_10 %<>%
  filter(SEX != 0,
         RACE != 0,
         AGEGRP != 0, 
         ORIGIN == 0) %>%
  dplyr::select(-REGION, -DIVISION, -ORIGIN, -STATE) %>%
  rename("STATE" = NAME,
         "AGE_GROUP" = AGEGRP)

dem_00_10
```


Now we need to recode the numeric values to the values in the techincal documentation. We can do so by adding labels to each numeric level using the base function `factor()`.

```{r}
dem_00_10 %<>%
  mutate(SEX = factor(SEX,
                            levels = 1:2,
                            labels = c("Male",
                                    "Female")),
         RACE = factor(RACE,
                            levels = 1:6,
                            labels = c("White",
                                    "Black",
                                    rep("Other",4))),
         AGE_GROUP = factor(AGE_GROUP,
                            levels = 1:18,
                            labels = pull(distinct(dem_77_79,AGE_GROUP), AGE_GROUP)))
                            
glimpse(dem_00_10)
```

OK, we also want to change the shape of the data so that we have a `YEAR` variable and each estimate of the population is a value in a new variable called `SUB_POP_temp`. 

```{r}
dem_00_10 %<>%
  pivot_longer(cols=contains("ESTIMATE"),
               names_to = "YEAR",
               values_to = "SUB_POP_temp")
```

We will now clean up the `YEAR` variable to only be the numeric value by keeping only the last 4 values of each string using the `str_sub()` function of the `stringr` package.

```{r}
dem_00_10 %<>%
  mutate(YEAR = str_sub(YEAR, start=-4)) %>%
  mutate(YEAR = as.numeric(YEAR))
```


Now we will collapse the data for the different RACES and calculate a new `SUB_POP` value. 

```{r}
dem_00_10 %<>%
  group_by(YEAR, AGE_GROUP, STATE, SEX, RACE) %>%
  summarise(SUB_POP = sum(SUB_POP_temp), .groups = "drop")
```

Agian, the dimensions look as we expect with 60,588 rows. This time we have two levels of `SEX`, three levels of `Race`, **11** levels of `YEAR`, eighteen levels of `AGE_GROUP`, and fifty one levels of `STATE`. If we multiply this together we get 16,588. Looks good!

Now we will calculate the total polutation and percent of the total as we have done with the previous decades.


```{r}
pop_00_10 <- dem_00_10 %>%
  group_by(YEAR, STATE) %>%
  summarise(TOT_POP = sum(SUB_POP), .groups = "drop")
```

We can also check that our wrangling was performecd correctly by summing the values for the individual subpopulations percentages and seeing if it totals to 100.

```{r}
dem_00_10 %>%
  left_join(pop_00_10, by=c("YEAR", "STATE")) %>%
  group_by(YEAR, STATE) %>%
  mutate(PERC_SUB_POP = (SUB_POP/TOT_POP)*100) %>%
  summarise(perc_tot = sum(PERC_SUB_POP), .groups = "drop") %>%
  mutate(poss_error = case_when(abs(perc_tot - 100) > 0 ~ TRUE,
                                TRUE ~ FALSE)) %>%
  group_by(poss_error) %>%
  tally()

```

Looks like the percentages for each state for each year all add up to 100, as we would expect. Great! Now we will reasign the `dem_00_10` data with this processing. 

```{r}
dem_00_10 %<>%
  left_join(pop_00_10, by = c("YEAR", "STATE")) %>%
  mutate(PERC_SUB_POP = (SUB_POP/TOT_POP)*100) %>%
 select(-SUB_POP, -TOT_POP)

dem_00_10
```

OK, now we are ready to combine all of our demgraphic data together!

</details>

### Combining demographic data

We can check that the colnames are the same for the data for each of the decades by using the `setequal()` function of the `dplyr` package.

```{r}
setequal(colnames(dem_77_79),colnames(dem_80_89))
setequal(colnames(dem_80_89),colnames(dem_90_99))
setequal(colnames(dem_90_99),colnames(dem_00_10))
```


We can also confirm that we have the same number of age groups for each decade by using the base `length()` function. If you did not take a look at the wrangling for the demographic data then you may be unfamiliar with the `pull()` function of the `dplyr` package. This allows you to grab the values of a variable from a tibble. The `distinct()` function which is also of the `dplyr` package creates a tibble of the unique values for a variable.

```{r}
length(pull(distinct(dem_77_79, AGE_GROUP), AGE_GROUP))
length(pull(distinct(dem_80_89, AGE_GROUP), AGE_GROUP))
length(pull(distinct(dem_90_99, AGE_GROUP), AGE_GROUP))
length(pull(distinct(dem_00_10, AGE_GROUP), AGE_GROUP))
```

Looks good!


Now we will combine the data using the `bind_rows()` function of the `dplyr` package. This function appends the data together based on the presence of columns with the same name in the different tibbles.

```{r}
dem <- bind_rows(dem_77_79,
                 dem_80_89,
                 dem_90_99,
                 dem_00_10)
```


```{r}
glimpse(dem)
```

Great! now we have a really large single tibble.

Now we want to select similar demographic data to what was used in the previous analyses.

Here is the table from the [Donohue paper](https://www.nber.org/papers/w23510.pdf){target="_blank"} that compares the data used in the analyses.


```{r, echo=FALSE, out.height = '100%', out.width = '100%', fig.align='center'}
knitr::include_graphics(here("img",'Donohue_Table2.png'))
```
We can see that only the percentage of males that were from age 15-39 of the race groups (black, white, and other) were used in the Donohue analysis.

Ultimately we intend to make a tibble of data that is similar to each analysis. Therefore, we will create a data tibble about the demogrphaic data for each analysis now.

To do so we will first create a vector of the age groups that should be included in the Donohue-like analysis, that we will call `DONOHUE_AGE_GROUPS`. We will then filter for only the age groups in this vector by using the `filter()` function of the `dplyr` package and the `%in%` operator to indicate that we want to keep all `AGE_GROUP` values that are equal to those within `DONOHUE_AGE_GROUPS`. We also want to filter for only population percentages for males by using the `==` operator. Then we can collpase the age groups from 20-39 by using the `fct_collpase()` function of the `forcats` package.

```{r}
DONOHUE_AGE_GROUPS <- c("15 to 19 years",
                        "20 to 24 years",
                        "25 to 29 years",
                        "30 to 34 years",
                        "35 to 39 years")

dem_DONOHUE <- dem %>%
  filter(AGE_GROUP %in% DONOHUE_AGE_GROUPS,
               SEX == "Male") %>%
  mutate(AGE_GROUP = fct_collapse(AGE_GROUP, "20 to 39 years"=c("20 to 24 years",
                                                                "25 to 29 years",
                                                                "30 to 34 years",
                                                                "35 to 39 years")))

dem_DONOHUE
```

We also want to create a new variable that will contain all the demographic information for each percentage just as was done in the [Donohue, et al.](https://www.nber.org/papers/w23510.pdf){target="_blank"} analysis. This should result in 6 different demographic variables.

To do this we will modify the `AGE_GROUP` variable by using the `mutate()` function of the `dplyr` package. We will replace the spaces in the now two age group categorise with and undesrscore using the `str_replace_all()` function of the `stringr` package which replaces all instances of a pattern in a character string. 

Then we will use the `group_by()` function and the `summarise()` funtion also of the `dplyr` package to allow us to calculate a sum of the percentages for each of the subpopulation percentages for the newly modifed age groups in `AGE_GROUP`. The `.groups = "drop"` argument allows for the grouping to be removed after the `summarise()` function.

```{r}
dem_DONOHUE %<>%
  mutate(AGE_GROUP = str_replace_all(string = AGE_GROUP, 
                                     pattern = " ", 
                                     replacement = "_")) %>%
  group_by(YEAR, STATE, RACE, SEX, AGE_GROUP) %>%
  summarise(PERC_SUB_POP = sum(PERC_SUB_POP), .groups = "drop")

dem_DONOHUE
```

Now we will combine the variables `RACE`, `SEX`, and `AGE_GROUP` together into one string separated by underscores using the `unite` function of the `tidyr` package. we will call this new variable `VARIABLE`.
We will rename the `PERC_SUB_POP` variable to be `VALUE` using the `rename()` function of the `dplyr` package. The new name should be listed first before the `=`.

```{r}
dem_DONOHUE %<>%
  unite(col = "VARIABLE", RACE, SEX, AGE_GROUP, sep = "_") %>%
  rename("VALUE" = PERC_SUB_POP)

dem_DONOHUE
```

Let's do a quick row number check. We have six different demographic variables, 51 states (DC counts as a state in this case), and 34 different years from 1977 to 2010, we should have 10,404 rows, which we do!

Now, let's do the same for the "Lott-like" analysis.


```{r, echo=FALSE, out.height = '100%', out.width = '100%', fig.align='center'}
knitr::include_graphics(here("img",'Donohue_Table2.png'))
```

So, in this analysis there were 36 variables covering percentages of indiviuals from 10 to over 65, three  race groups and both males and females. This table is misprinted and does not include the word "Other" for the third race group that was used. 

First we will filter out the age groups that were not included. Then we will collapse the age groups to those that were used by Lott et al. again using the `fct_collpase()` function of the `forcats` package. 

Also we will again combine the values across the variables to create a new demographic varaible with 36 levels. 

```{r}
LOTT_AGE_GROUPS_NULL <- c("Under 5 years",
                          "5 to 9 years")

dem_LOTT <- dem %>%
  filter(!(AGE_GROUP %in% LOTT_AGE_GROUPS_NULL) )%>%
  mutate(AGE_GROUP = fct_collapse(AGE_GROUP,
                                  "10 to 19 years"=c("10 to 14 years",
                                                     "15 to 19 years"),
                                  "20 to 29 years"=c("20 to 24 years",
                                                     "25 to 29 years"),
                                  "30 to 39 years"=c("30 to 34 years",
                                                     "35 to 39 years"),
                                  "40 to 49 years"=c("40 to 44 years",
                                                     "45 to 49 years"),
                                  "50 to 64 years"=c("50 to 54 years",
                                                     "55 to 59 years",
                                                     "60 to 64 years"),
                                  "65 years and over"=c("65 to 69 years",
                                                        "70 to 74 years",
                                                        "75 to 79 years",
                                                        "80 to 84 years",
                                                        "85 years and over"))) %>%
  mutate(AGE_GROUP = str_replace_all(AGE_GROUP," ","_")) %>%
  group_by(YEAR, STATE, RACE, SEX, AGE_GROUP) %>%
  summarise(PERC_SUB_POP = sum(PERC_SUB_POP), .groups = "drop") %>%
  unite(col = "VARIABLE", RACE, SEX, AGE_GROUP, sep = "_") %>%
  rename("VALUE"=PERC_SUB_POP)
```

We can indeed check that we have the correct number of levels for `VARIABLE` using the `distinct()` function.

```{r}
 distinct(dem_LOTT, VARIABLE)
```
  
### Combining population Data

We also have population data for each decade that came from wrangling the demogrphic data.

We again want to combine this data, so let's again make sure that all the different tibbles have the same column names.

```{r}
setequal(colnames(pop_77_79),colnames(pop_80_89))
setequal(colnames(pop_80_89),colnames(pop_90_99))
setequal(colnames(pop_90_99),colnames(pop_00_10))

head(pop_77_79)
head(pop_80_89)
head(pop_90_99)
head(pop_00_10)
```

Looks good!

```{r}
population_data <- bind_rows(pop_77_79,
                             pop_80_89,
                             pop_90_99,
                             pop_00_10)

population_data <- population_data %>%
  mutate(VARIABLE = "Population") %>%
  rename("VALUE"=TOT_POP)
```

We could check that we have 51 values for each year by using the `count()` function of the `dplyr` package.

```{r}
population_data %>%
  count(YEAR)
```

## Police staffing

<detials> <summary> click here to see detials about how the plice staffing data was wrangled. </summary>

OK, now we will wrangle the police staffing data. We want to limit the data to only the years of interest. Then we will also replace NA values with zero for the `male_total_ct` and `female_total_ct` variables using the `replace_na()` function of the `tidyr` packge. We will also, use the `across()` function of the `dplyr` package to select and mutate both of these columns in this way. Since both of these variables have `total_ct` in the name and no other variables do, we can use the `contains()` function of the `dplyr` package to specify that we want to use these columns instead of listing both out.

avocado... why not 2010....

```{r}
glimpse(ps_data)

ps_data %<>%
  filter(data_year >= 1977, 
         data_year <= 2014) %>%
mutate(across(.cols =contains("total_ct"), ~replace_na(., 0)))

glimpse(ps_data)
```

Now we can create a new variable called `officer_total` which will be the sum of these variables. We will then keep just this variable as well as the `data_year`, `pub_agency_name`, and `state_abbr`.

```{r}

ps_data %<>%
  mutate(officer_total = male_total_ct + female_total_ct) %>%
  dplyr::select(data_year,
                pub_agency_name,
                state_abbr,
                officer_total)

ps_data
```

Now we also want to get collapse by `pub_agency_name` to get a total count for each year and each state. So we will do this by using the `group_by()` function and grouping by `data_year` and `state_abbr` and using the `summarise()` function to calculate a sum.

```{r}
ps_data %<>%
  group_by(data_year, state_abbr) %>%
  summarise(officer_state_total=sum(officer_total), .groups = "drop")

ps_data
```
And we will check that we have same number of values (the number of years included in the data) for each state.

```{r}
ps_data %>%
  count(state_abbr) 
```
We will remove a few states now.
AVocado- why?
NB is  Nebraska. This was changed to NE to avoid confusions with NB in Canada. This dataset uses NB

```{r}

state_of_interest_NULL <- c("AS",
                            "GM",
                            "CZ",
                            "FS",
                            "MP",
                            "OT",
                            "PR",
                            "VI")

state_abb_df <- as.data.frame(cbind(state.abb, state.name))

colnames(state_abb_df) <- c("state_abbr", "STATE")

print(state_abb_df)

state_abb_df <- state_abb_df %>%
  add_row(state_abbr="DC",
          STATE="District of Columbia")

denominator_temp <- population_data %>%
  dplyr::select(-VARIABLE) %>%
  rename("Population_temp"=VALUE)

ps_data <- ps_data %>%
  filter(!(state_abbr %in% state_of_interest_NULL)) %>%
  mutate(state_abbr = case_when(state_abbr == "NB" ~ "NE",
                                TRUE ~ state_abbr)) %>%
  left_join(state_abb_df, by = "state_abbr") %>%
  dplyr::select(-state_abbr) %>%
  rename(YEAR = "data_year",
         VALUE = "officer_state_total") %>%
  mutate(VARIABLE = "officer_state_total") %>%
  left_join(denominator_temp, by=c("STATE","YEAR")) %>%
  mutate(VALUE = (VALUE*100000) / Population_temp) %>%
  mutate(VALUE = lag(VALUE)) %>%
  mutate(VARIABLE = "police_per_100k_lag") %>%
  dplyr::select(-Population_temp)
```
</details>


## Unemployment

The first thing we need to do with the unemployment data is combine the data across the different states.
 We can do that using the `bind_rows()` function of `dplyr` which appends the data together based on the presence of columns with the same name in the different tibbles. We will use the `map_df()` function of the `purrr` package to allow us to do this across each tibble in our list. We will then select just the annual data for each state and year and we will rename our variables to be consistent with some of other data that we are working with. Thus we would like our variabels to be `YEAR`, `VALUE` and `VARIABLE` in all caps.
 
```{r}

ue_rate_data <- ue_rate_data %>%
  map_df(bind_rows, .id = "STATE")

head(ue_rate_data)

ue_rate_data <- ue_rate_data %>%
 # mutate(Year = as.numeric(Year)) %>%
  dplyr::select(STATE, Year, Annual) %>%
  rename("YEAR" = Year,
        "VALUE" = Annual) %>%
  mutate(VARIABLE = "Unemployment_rate")

head(ue_rate_data)
```

## Poverty rate

OK, now for wrangling the poverty data. First let's take a look at it. 
```{r}
head(poverty_rate_data)
```

We can see that the column names are actually shifted downbelow the row with the year. So we will manually make these values the actual column names.

```{r}
colnames(poverty_rate_data) <- c("STATE",
                                 "Total",
                                 "Number",
                                 "Number_se",
                                 "Percent",
                                 "Percent_se")

poverty_rate_data2 <-poverty_rate_data

```

Let's also remove the rows where the column names are listed, like row number 2.

```{r}
poverty_rate_data  %<>%
  filter(STATE != "STATE")
head(poverty_rate_data)
```

We can also see that there are some extra notes at the end of our data. This is why it is a good idea to look at both the head and tail of your data.

```{r}
tail(poverty_rate_data)
```
We can see that the strings for the state for these rows are very long. We can also see that there are rows that just have the year, where the state is only 4 characters long. We will create a new variable called `length_state` based on the number of characters in the `STATE` values. We will use the `str_length()` function of the `stringr` package. We need to use the `map_dbl()` function to apply this to each row of the `STATE` variable. The `map()` function creates a list, whereas the `map_dbl()` function creates a vector of class double. If we were to use `map()` we would need to use `unlist()` and `pull()`.

```{r}

poverty_rate_data %<>%
 mutate(length_state = map_dbl(STATE, str_length))

# Alternatively with map()
#poverty_rate_data %<>%
#mutate(length_state = unlist(map(pull(poverty_rate_data, STATE), str_length)))

poverty_rate_data
```


Great, now let's look at the tail with our new variable `length_state`
```{r}
tail(pull(poverty_rate_data, length_state))

```

```{r}
poverty_rate_data %<>% 
  filter(length_state <100)

tail(poverty_rate_data)
```
Looks good!

Now let's select all the states that are actually year values to create a new variable about the year. We can do so by using the `str_detect()` function of the `stringr` package to look for digits or values of 0-9. This is indicated by using the `"[:digit:]"`.

As you can see in the [RStudio cheatsheet](https://rstudio.com/resources/cheatsheets/){target="_blank"}  about regular expressions this notation indicates any digit between 0 and 9.

```{r}
knitr::include_graphics(here("img", "regex.png"))
```
#### {.scrollable }
```{r}
# scroll through the output!
poverty_rate_data %>% 
  filter(str_detect(STATE, "[:digit:]"))
```
####

Some of the years (2013 and 2017) are listed twice with a number in parantheses, others are just listed once with a number in parantheses. Looking at the technical documentation, this seems to do with updates to the defition of poverty and to the methods used to estimate poverty levels. See [here](https://www.census.gov/topics/income-poverty/poverty/guidance/poverty-footnotes/cps-historic-footnotes.html){target="_blank"} and [here](https://www2.census.gov/programs-surveys/cps/techdocs/cpsmar19.pdf){target="_blank"} for more information. We will simply select one of the sets of data for 2013 and 2017.

```{r}
poverty_rate_data %>% 
  filter(str_detect(STATE, "2013")) %>%
  filter(str_detect(STATE, "2017"))
```

First let's add the year value to our data. 


There should be consistently data for 51 states (including DC). We can see that sometimes DC is spelled out and sometimes it is not.

#### {.scrollable }
```{r}
### Scroll through the output!
poverty_rate_data %>% 
  filter(str_detect(STATE, "[:alpha:]")) %>%
  distinct(STATE) %>% print(n = 100)

```
####


Now we will replace `"D.C."` with `"District of Columbia"` using `str_replace()`. We can use the `tally()` function of the `dplyr` package to check that we have fewer now.

```{r}
poverty_rate_data %<>% 
mutate(STATE = str_replace(STATE, pattern = "D.C.", 
                              replacement = "District of Columbia" ))

poverty_rate_data %>% 
  filter(str_detect(STATE, "[:alpha:]")) %>%
  distinct(STATE) %>% tally()
```
Great! Now are each of the states occurring as often as the unique year values? We can first check how many year values there are. Then can use the `count()` function of the `dplyr` package to check how often the states are repeated.

```{r}

poverty_rate_data %>% 
  filter(str_detect(STATE, "[:digit:]")) %>%
  tally()
```

There are 41 different sets of data according to year values.

#### {.scrollable }
```{r}
### Scroll through the output!
poverty_rate_data %>% 
  filter(str_detect(STATE, "[:alpha:]")) %>%
  count(STATE)
```
####
Indeed, looks like each of the states are repeated the same number of times!

Now let's create a new variable `YEAR` that repeats the year values for all of the different states and for the row that has just the year value for a total of 52.

```{r}

year_values <- poverty_rate_data %>% 
  filter(str_detect(STATE, "[:digit:]")) %>%
  distinct(STATE)

  year_values<-rep(pull(year_values, STATE), each = 52)
setequal(length(year_values), length(poverty_rate_data$STATE))
```

Now we will add this to our `poverty_rate_data`. We will also remove the `length_state` variable using the `select()` function of the `dplyr` package and a minus sign before the variable name.

```{r}
poverty_rate_data %<>%
  mutate(year_value = year_values) %>%
  select(-length_state)
```

#### {.scrollable }
```{r}
#Scroll through the output!
poverty_rate_data %>% print(n = 100)
```
####

Looks good! Now we will remove the rows that have just the year values by only preserving those with alpha characters.

```{r}
poverty_rate_data %<>%
    filter(str_detect(STATE, "[:alpha:]"))

```

Now let's remove the older data for 2013 and 2017 which is the data that appears lower in the tibble.

```{r}
poverty_rate_data %<>%
filter(year_value != "2017") %>%
filter(year_value != "2013 (18)")
```


We also want to just keep the first 4 digits of the year_value and create a `YEAR` variable. We need to pull the `year_value` data because `str_sub()` expects a character vector not a tibble.

```{r}
poverty_rate_data %<>%
  mutate(YEAR = str_sub(pull(., year_value), start = 1, end=4))
```

#### {.scrollable }
```{r}
poverty_rate_data 
```
####

Looks good! Now we will just remove the extra variables and rename the variables we want to keep to be similar to our other data.

```{r}
poverty_rate_data %<>%
  dplyr::select(- Number,
                - Number_se,
                - Percent_se,
                - Total,
                - year_value) %>%
  rename("VALUE" = Percent) %>%
  mutate(VARIABLE = "Poverty_rate",
         YEAR = as.numeric(YEAR),
         VALUE = as.numeric(VALUE))
head(poverty_rate_data)
```

Looks great! AVOCADO this data is per 1000k? I think I need to restrict to 2014 to match the other data and thats why I get an error when making the Donohue_df 


From Michael:
```{r, eval = FALSE}

poverty_rate_data <-poverty_rate_data2
notes <- 4

poverty_rate_data2 <- poverty_rate_data[-((dim(poverty_rate_data)[1]-notes+1):dim(poverty_rate_data)[1]),]

states_eq <- 51

extra_col <- 2

rep_rows <- states_eq + extra_col

groups <- (dim(poverty_rate_data)[1])/(rep_rows)

paste(groups - (2018-1980 + 1), "extra groups")

poverty_rate_data$year_group <- rep(1:groups, each=rep_rows)

poverty_rate_data <- poverty_rate_data %>%
  group_by(year_group) %>%
  group_split()

head(poverty_rate_data[[1]])

poverty_rate_data <- poverty_rate_data %>%
  map(~mutate(.,
              row_id = row_number())) %>%
  map(~filter(.,row_id != 2)) %>%
  map(~dplyr::select(.,-row_id))

poverty_rate_data_names <- poverty_rate_data %>%
  sapply(., "[",1,1, drop=TRUE) %>%
  str_replace_all(.,"[:space:]","_")

names(poverty_rate_data) <- poverty_rate_data_names

# Recall 2 extra groups. 
# footnotes available at https://www.census.gov/topics/income-poverty/poverty/guidance/poverty-footnotes/cps-historic-footnotes.html

poverty_rate_data$`2017_(21)` <- NULL

poverty_rate_data$`2013_(19)` <- NULL

poverty_rate_data_names <- poverty_rate_data %>%
  sapply(., "[",1,1, drop=TRUE) %>%
  str_sub(., start = 1, end=4)

names(poverty_rate_data) <- poverty_rate_data_names

poverty_rate_data <- poverty_rate_data %>%
  map_df(bind_rows, .id = "YEAR") %>%
  dplyr::select(-year_group)

poverty_rate_data <- poverty_rate_data %>%
    mutate(n_na = rowSums(is.na(.))) 

# This shows that there is systematic missing values stemmingly *solely* from the rows without poverty data and only a label designating the year
poverty_rate_data %>% 
  group_by(n_na) %>%
  tally()

sapply(poverty_rate_data, class)



colnames(poverty_rate_data)
```

## Violent crime

```{r}
length(crime_data)

crime_data <- crime_data[-(2143:length(crime_data))]

x <- 2014-1977+1

rep_cycle <- 2 + 2 + x

rep_cycle_cut <- 2 + x

delete_rows <- c(seq(2,length(crime_data),rep_cycle),
                 seq(3,length(crime_data),rep_cycle))

crime_data <- crime_data[-delete_rows]

crime_data <- data.frame(cbind(crime_data, rep(1:(length(crime_data)/rep_cycle_cut),each=rep_cycle_cut)))

colnames(crime_data) <- c("String","STATE_GROUP")

crime_data <- crime_data %>%
  group_by(STATE_GROUP) %>%
  group_split()

columns_crime_data <- 8

crime_data <- crime_data %>%
  map(~mutate(.,
               State = case_when(str_detect(String, "Estimated crime in ") ~ substring(String, nchar("Estimated crime in ")+1)),
              row_id = row_number())) %>%
  map(~fill(., State)) %>%
  map(~filter(.,row_id > 2)) %>%
  map(~mutate(.,
              String = paste0(String, ",", State))) %>%
  map(~dplyr::select(.,String)) %>%
  map(~str_split_fixed(.$String,",",columns_crime_data + 1)) %>%
  map(~data.frame(.)) %>%
  map(~rename(.,"YEAR"=X1,
              "Extra_col1"=X2,
              "VC"=X3,
              "Extra_col2"=X4,
              "Extra_col3"=X5,
              "Extra_col4"=X6,
              "Extra_col5"=X7,
              "Extra_col6"=X8,
              "STATE"=X9)) %>%
  map(~dplyr::select(.,-contains("Extra_col"))) %>%
  map(~.x %>% mutate_all(~trimws(.,which = "both"))) %>%
  map_df(bind_rows)

sapply(crime_data, class)

crime_data <- crime_data %>%
  mutate(VARIABLE = "Viol_crime_count") %>%
  rename("VALUE" = VC) %>%
  as.tibble() %>%
  mutate(YEAR = as.numeric(YEAR),
         VALUE = as.numeric(VALUE))
```

## RTC laws

```{r}
DAWpaper_p_62 <- DAWpaper[[62]]

p_62 <- DAWpaper_p_62 %>%
    strsplit("\n") %>%
    unlist() %>%
    as.data.frame() %>%
    slice(-(1:2))

apply(p_62, 1, nchar)

p_62[53,] #physcial page 60

p_62 <- p_62 %>%
    slice(-53)

apply(p_62, 1, str_count, "\\s{5,}")
apply(p_62, 1, str_count, "\\s{10,}")
apply(p_62, 1, str_count, "\\s{20,}")
apply(p_62, 1, str_count, "\\s{40,}")

head(cbind(p_62, apply(p_62, 1, str_count, "\\s{40,}")))

p_62 <- p_62 %>%
    apply(1,str_replace_all, "\\s{40,}", "|N/A|") %>%
    str_replace_all("\\s{2,15}", "|") %>%
    as.data.frame()

p_62 <- sapply(p_62$., str_split, "\\|{1,}")

sapply(p_62, nchar)

p_62 <- lapply(p_62, function(x) x[nchar(x) > 0]) 

p_62 <- as.data.frame(do.call(rbind, p_62))

rownames(p_62)

rownames(p_62) <- c()

colnames(p_62) <- c("STATE",
                    "E_Date_RTC",
                    "Frac_Yr_Eff_Yr_Pass",
                    "RTC_Date_SA")
sapply(p_62, class)

p_62 <- p_62 %>%
  dplyr::select(STATE, RTC_Date_SA) %>%
  rename("RTC_LAW_YEAR"=RTC_Date_SA) %>%
  mutate(RTC_LAW_YEAR = as.numeric(RTC_LAW_YEAR)) %>%
  mutate(RTC_LAW_YEAR = case_when(RTC_LAW_YEAR == 0 ~ Inf,
                              TRUE ~ RTC_LAW_YEAR))

sapply(p_62, class)

head(p_62)
```

## Checkpoint
```{r}
colnames(dem_DONOHUE)
colnames(dem_LOTT)
colnames(ue_rate_data)
colnames(poverty_rate_data)
colnames(crime_data)

head(dem_DONOHUE)
head(dem_LOTT)
head(ue_rate_data)
head(poverty_rate_data)
head(crime_data)
```
```{r}
crime_data %>% distinct(STATE) %>% tally()
crime_data %>% distinct(YEAR) %>% tally()

```

## Join

## Donohue, et al.

```{r}
DONOHUE_DF <- bind_rows(dem_DONOHUE,
                        ue_rate_data,
                        poverty_rate_data,
                        crime_data,
                        population_data,
                        ps_data) %>%
  pivot_wider(names_from = "VARIABLE",
              values_from = "VALUE") %>%
  left_join(p_62 , by = c("STATE")) %>%
  mutate(RTC_LAW = case_when(YEAR >= RTC_LAW_YEAR ~ TRUE,
                              TRUE ~ FALSE))

DONOHUE_DF %>%
  group_by(YEAR) %>%
  tally() %>%
  filter(n != 51) %>%
  print(n=dim(.)[1])

summary(as.factor(DONOHUE_DF$STATE))

max(DONOHUE_DF$YEAR) - min(DONOHUE_DF$YEAR) + 1

DONOHUE_DF <- DONOHUE_DF %>%
  mutate(STATE = fct_collapse(STATE, "District of Columbia"=c("District of Columbia","D.C.")))

summary(as.factor(DONOHUE_DF$STATE))
  
length(levels(DONOHUE_DF$STATE))

DONOHUE_DF <- DONOHUE_DF %>%
  group_by(STATE, YEAR) %>%
  summarise_all(~na.omit(unique(.))) %>%
  ungroup() # This identifies unique observations, coalesces rows according to the grouping variable(s), and gets rid of of units that have incomplete data. This gives returns a dataframe with the most complete information.

summary(as.factor(DONOHUE_DF$STATE)) 

baseline_year <- min(DONOHUE_DF$YEAR)
censoring_year <- max(DONOHUE_DF$YEAR)

# Need to fix this to ensure severe bias is not introduced by prevalent "cases"

DONOHUE_DF <- DONOHUE_DF %>%
  mutate(TIME_0 = baseline_year,
         TIME_INF = censoring_year) %>%
  filter(RTC_LAW_YEAR > TIME_0)

DONOHUE_DF <- DONOHUE_DF %>%
  mutate(Viol_crime_rate_1k = (Viol_crime_count*1000)/Population,
         Viol_crime_rate_1k_log = log(Viol_crime_rate_1k),
         Population_log = log(Population))

summary(droplevels(as.factor(DONOHUE_DF$STATE)))

length(summary(droplevels(as.factor(DONOHUE_DF$STATE))))
```

## Lott and Mustard

```{r}
LOTT_DF <- bind_rows(dem_LOTT,
                     ue_rate_data,
                     poverty_rate_data,
                     crime_data,
                     population_data,
                     ps_data) %>%
  pivot_wider(names_from = "VARIABLE",
              values_from = "VALUE") %>%
  left_join(p_62 , by = c("STATE")) %>%
  mutate(RTC_LAW = case_when(YEAR >= RTC_LAW_YEAR ~ TRUE,
                              TRUE ~ FALSE))

LOTT_DF %>%
  group_by(YEAR) %>%
  tally() %>%
  filter(n != 51) %>%
  print(n=dim(.)[1])

summary(as.factor(LOTT_DF$STATE))

max(LOTT_DF$YEAR) - min(LOTT_DF$YEAR) + 1

LOTT_DF <- LOTT_DF %>%
  mutate(STATE = fct_collapse(STATE, "District of Columbia"=c("District of Columbia","D.C.")))

summary(as.factor(LOTT_DF$STATE))
  
length(levels(LOTT_DF$STATE))

LOTT_DF <- LOTT_DF %>%
  group_by(STATE, YEAR) %>%
  summarise_all(~na.omit(unique(.))) %>%
  ungroup() # This identifies unique observations, coalesces rows according to the grouping variable(s), and gets rid of of units that have incomplete data. This gives returns a dataframe with the most complete information.

summary(as.factor(LOTT_DF$STATE)) 

baseline_year <- min(LOTT_DF$YEAR)
censoring_year <- max(LOTT_DF$YEAR)

# Need to fix this to ensure severe bias is not introduced by prevalent "cases"

LOTT_DF <- LOTT_DF %>%
  mutate(TIME_0 = baseline_year,
         TIME_INF = censoring_year) %>%
  filter(RTC_LAW_YEAR > TIME_0)

LOTT_DF <- LOTT_DF %>%
  mutate(Viol_crime_rate_1k = (Viol_crime_count*1000)/Population,
         Viol_crime_rate_1k_log = log(Viol_crime_rate_1k),
         Population_log = log(Population))

summary(droplevels(as.factor(LOTT_DF$STATE)))

length(summary(droplevels(as.factor(LOTT_DF$STATE))))
```

# **Data Exploration**
***

```{r}
sapply(DONOHUE_DF, class)

DONOHUE_DF %>%
  mutate(Viol_crime_rate_100k_log = log((Viol_crime_count*100000)/Population)) %>%
  ggplot(aes(x = YEAR, y = Viol_crime_rate_100k_log, color = STATE)) +
  geom_point(size = 0.5) +
  geom_line(aes(group=STATE),
            size = 0.5,
            show.legend = FALSE) +
  geom_text_repel(data = DONOHUE_DF %>%
              mutate(Viol_crime_rate_100k_log = log((Viol_crime_count*100000)/Population)) %>%
              filter(YEAR == last(YEAR)),
            aes(label = STATE,
                x = YEAR,
                y = Viol_crime_rate_100k_log),
            size = 3,
            alpha = 1,
            nudge_x = 10,
            direction = "y",
            hjust = 1,
            vjust = 1,
            segment.size = 0.25,
            segment.alpha = 0.25,
            force = 1,
            max.iter = 9999) +
  guides(color = FALSE) +
  scale_x_continuous(breaks = seq(1980, 2015, by = 1),
                     limits = c(1980, 2015),
                     labels = c(seq(1980, 2010, by = 1), rep("", 5))) +
  scale_y_continuous(breaks = seq(3.5, 8.5, by = 0.5),
                     limits = c(3.5, 8.5)) +
  labs(title = "States have different levels of crime",
       x = "Year",
       y = "ln(violent crimes per 100,000 people)") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90))

DONOHUE_DF %>%
  group_by(YEAR) %>%
  summarise(Viol_crime_count = sum(Viol_crime_count),
            Population = sum(Population),
            .groups = "drop") %>%
  mutate(Viol_crime_rate_100k_log = log((Viol_crime_count*100000)/Population)) %>%
  ggplot(aes(x = YEAR, y = Viol_crime_rate_100k_log)) +
  geom_line() +
  scale_x_continuous(breaks = seq(1980, 2010, by = 1),
                     limits = c(1980, 2010),
                     labels = c(seq(1980, 2010, by = 1))) +
  scale_y_continuous(breaks = seq(5.75, 6.75, by = 0.25),
                     limits = c(5.75, 6.75)) +
  labs(title = "Crime rates fluctuate over time",
       x = "Year",
       y = "ln(violent crimes per 100,000 people)") +
  theme_minimal() + 
  theme(axis.text.x = element_text(angle = 90))
```

# **Data Analysis**
***

## Donohue, et al.

Some code taken from http://karthur.org/2019/implementing-fixed-effects-panel-models-in-r.html

```{r}
d_panel_DONOHUE <- pdata.frame(DONOHUE_DF, index=c("STATE", "YEAR"))

DONOHUE_OUTPUT <- plm(Viol_crime_rate_1k_log ~
                        RTC_LAW +
                        White_Male_15_to_19_years +
                        White_Male_20_to_39_years +
                        Black_Male_15_to_19_years +
                        Black_Male_20_to_39_years +
                        Other_Male_15_to_19_years +
                        Other_Male_20_to_39_years +
                        Unemployment_rate +
                        Poverty_rate + 
                        Population_log + 
                        police_per_100k_lag,
                      effect = "twoways",
                      model = "within",
                      data=d_panel_DONOHUE)

summary(DONOHUE_OUTPUT)

DONOHUE_OUTPUT_TIDY <- tidy(DONOHUE_OUTPUT, conf.int = 0.95)

DONOHUE_OUTPUT_TIDY$Analysis <- "Analysis 1"
```

## Lott and Mustard

Some code taken from http://karthur.org/2019/implementing-fixed-effects-panel-models-in-r.html

```{r}
LOTT_variables <- LOTT_DF %>%
  dplyr::select(RTC_LAW,
                contains(c("White","Black","Other")),
                Unemployment_rate,
                Poverty_rate,
                Population_log,
                police_per_100k_lag) %>%
  colnames()

LOTT_fmla <- as.formula(paste("Viol_crime_rate_1k_log ~",
                              paste(LOTT_variables, collapse = " + ")
                              )
                        )

d_panel_LOTT <- pdata.frame(LOTT_DF, index=c("STATE", "YEAR"))

LOTT_OUTPUT <- plm(LOTT_fmla,
                      model = "within",
                   effect = "twoways",
                      data=d_panel_LOTT)

summary(LOTT_OUTPUT)

LOTT_OUTPUT_TIDY <- tidy(LOTT_OUTPUT, conf.int = 0.95)

LOTT_OUTPUT_TIDY$Analysis <- "Analysis 2"
```

## Comparing analyses

```{r}
comparing_analyses <- DONOHUE_OUTPUT_TIDY %>%
  bind_rows(LOTT_OUTPUT_TIDY) %>%
  filter(term == "RTC_LAWTRUE")

library(grid)

comparing_analyses_plot <- ggplot(comparing_analyses) + 
  geom_point(aes(x = Analysis, y = estimate)) +
  geom_errorbar(aes(x = Analysis, ymin = conf.low, ymax = conf.high), width = 0.25) + 
  geom_hline(yintercept = 0, color = "red") +
  scale_y_continuous(breaks = seq(-0.2, 0.2, by = 0.05),
                     labels = seq(-0.2, 0.2, by = 0.05),
                     limits = c(-0.2,0.2)) +
  geom_segment(aes(x = 1, y = 0.125, xend = 1, yend = 0.175),
               arrow = arrow(angle = 45, ends = "last", type = "open"),
               size = 2,
               color = "green",
               lineend = "butt",
               linejoin = "mitre") +
  geom_segment(aes(x = 2, y = -0.125, xend = 2, yend = -0.175),
               arrow = arrow(angle = 45, ends = "last", type = "open"),
               size = 2,
               color = "red",
               lineend = "butt",
               linejoin = "mitre") +
  theme_minimal() + 
  theme(axis.title.x = element_blank(),
        axis.text = element_text(size = 12)) +
  labs(title = "Effect estimate on ln(violent crimes per 100,000 people)",
       y = "Effect estimate (95% CI)")

comparing_analyses_plot
```

# Multicollinearity analysis

How did the above happen?

The analysis dataframes are very similar yet rendered very different results. 

```{r}
all_equal(target = DONOHUE_DF,
          current = LOTT_DF,
          ignore_col_order = TRUE,
          ignore_row_order = TRUE)

dim(DONOHUE_DF)[1] == dim(LOTT_DF)[1]
```

The only difference between the two dataframes rests in how the demographic variables were parameterized.

```{r}
DONOHUE_DF %>%
  dplyr::select(contains("years")) %>%
  colnames()

LOTT_DF %>%
  dplyr::select(contains("years")) %>%
  colnames()
```

Clearly, this had an effect on the results of the analysis. 

Let's explore how this occured. 

When seemingly independent variables are highly related to one another, the relationships estimated in an analysis may be distorted. 

In regression analysis, this distortion is often a byproduct of a violation of the independence assumption. This distortion, if large enough, can impact statistical inference. 

There are several ways we can diagnose multicollinearity.

### Correlation

Again, multicollinearity often occurs when independent variables are highly related to one another. Consequently, we can evaluate these relationships be examining the correlation between variable pairs.

<style>
div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px;}
</style>
<div class = "blue">

It is important to note that multicollinearity and correlation are not one and the same. Correlation can be thought of as the strength of the relationship between variables. On the other hand, multicollinearity can be thought of the the violation of the independence assumption that is a consequence of this correlation in a regression analysis. 

</div>

#### Scatterplots

```{r}
colnames(DONOHUE_DF)

DONOHUE_DF %>% 
  dplyr::select(RTC_LAW,
                Viol_crime_rate_1k_log,
                Unemployment_rate,
                Poverty_rate,
                Population_log) %>% 
  ggpairs(.,
          columns = c(2:5),
          lower = list(continuous = wrap("smooth_loess",
                                         color = "red",
                                         alpha = 0.5,
                                         size = 0.1)))

LOTT_DF %>% 
  dplyr::select(RTC_LAW,
                Viol_crime_rate_1k_log,
                Unemployment_rate,
                Poverty_rate,
                Population_log) %>% 
  ggpairs(.,
          columns = c(2:5),
          lower = list(continuous = wrap("smooth_loess",
                                         color = "red",
                                         alpha = 0.5,
                                         size = 0.1)))
```

#### Heatmaps

```{r}
cor_DONOHUE_dem <- cor(DONOHUE_DF %>% dplyr::select(contains("_years")))

corr_mat_DONOHUE <- ggcorrplot(cor_DONOHUE_dem,
           tl.cex = 6,
           hc.order = TRUE,
           colors = c("red",
                      "white",
                      "red"),
           outline.color = "transparent",
           title = "Correlation Matrix, Analysis 1",
           legend.title = TeX("$\\rho$"))

corr_mat_DONOHUE

cor_LOTT_dem <- cor(LOTT_DF %>% dplyr::select(contains("_years")))

corr_mat_LOTT <- ggcorrplot(cor_LOTT_dem,
           tl.cex = 6,
           hc.order = TRUE,
           colors = c("red",
                      "white",
                      "red"),
           outline.color = "transparent",
           title = "Correlation Matrix, Analysis 2",
           legend.title = TeX("$\\rho$"))

corr_mat_LOTT
```

### Coefficient estimate instability

```{r}
sims <- 250

# DONOHUE

# round(dim(DONOHUE_DF)[1]/2)
samps_DONOHUE <- lapply(rep(dim(DONOHUE_DF)[1]-1, sims),
       function(x)DONOHUE_DF[sample(nrow(DONOHUE_DF),
                                     size = x, replace = FALSE),])

fit_nls_on_bootstrap_DONOHUE <- function(split){
  plm(Viol_crime_rate_1k_log ~
                        RTC_LAW +
                        White_Male_15_to_19_years +
                        White_Male_20_to_39_years +
                        Black_Male_15_to_19_years +
                        Black_Male_20_to_39_years +
                        Other_Male_15_to_19_years +
                        Other_Male_20_to_39_years +
                        Unemployment_rate +
                        Poverty_rate + 
                        Population_log + 
                        police_per_100k_lag,
      data = data.frame(split),
      index = c("STATE","YEAR"),
      model = "within",
      effect = "twoways")
}
  
samps_models_DONOHUE <- lapply(samps_DONOHUE, fit_nls_on_bootstrap_DONOHUE)

samps_models_DONOHUE <- samps_models_DONOHUE %>%
  map(tidy)

names(samps_models_DONOHUE) <- paste0("DONOHUE_",1:length(samps_models_DONOHUE))

simulations_DONOHUE <- samps_models_DONOHUE %>%
  bind_rows(.id = "ID") %>%
  mutate(Analysis = "Analysis 1")

## LOTT

samps_LOTT <- lapply(rep(round(dim(LOTT_DF)[1]/2), sims),
       function(x) LOTT_DF[sample(nrow(LOTT_DF),
                                  size = x, replace = FALSE),])

fit_nls_on_bootstrap_LOTT <- function(split){
  plm(LOTT_fmla,
      data = data.frame(split),
      index = c("STATE","YEAR"),
      model = "within",
      effect = "twoways")
}
  
samps_models_LOTT <- lapply(samps_LOTT, fit_nls_on_bootstrap_LOTT)

samps_models_LOTT <- samps_models_LOTT %>%
  map(tidy)

names(samps_models_LOTT) <- paste0("LOTT_",1:length(samps_models_LOTT))

simulations_LOTT <- samps_models_LOTT %>%
  bind_rows(.id = "Analysis") %>%
  mutate(Analysis = "Analysis 2")

simulations <- bind_rows(simulations_DONOHUE,
                         simulations_LOTT)

simulation_plot <- simulations %>%
  filter(term=="RTC_LAWTRUE") %>%
  ggplot(aes(x = Analysis, y = estimate)) + 
  geom_jitter(alpha = 0.25,
              width = 0.1) + 
  labs(title = "Coefficient instability",
       subtitle = "Estimates sensitive to observation deletions",
       x = "Term",
       y = "Coefficient",
       caption = "Results from simulations") + 
  theme_minimal() +
  theme(axis.title.x = element_blank())

simulation_plot
```

### VIF

```{r}
design.matrix <- as.data.frame(model.matrix(DONOHUE_OUTPUT))

design.matrix$Viol_crime_rate_1k_log <- plm::Within(
  d_panel_DONOHUE$Viol_crime_rate_1k_log)

lm_DONOHUE <- lm(Viol_crime_rate_1k_log ~
                        RTC_LAWTRUE + # logical class changes variable name after inital model
                        White_Male_15_to_19_years +
                        White_Male_20_to_39_years +
                        Black_Male_15_to_19_years +
                        Black_Male_20_to_39_years +
                        Other_Male_15_to_19_years +
                        Other_Male_20_to_39_years +
                        Unemployment_rate +
                        Poverty_rate + 
                        Population_log +
               police_per_100k_lag,
             data = design.matrix)


vif(lm_DONOHUE)

vif_DONOHUE <- vif(lm_DONOHUE)

vif_DONOHUE <- vif_DONOHUE %>%
  as_tibble() %>%
  cbind(., names(vif_DONOHUE)) %>%
  as_tibble()
  
colnames(vif_DONOHUE) <- c("VIF", "Variable")

max_vif_DONOHUE <- max(vif(lm_DONOHUE)) 
```

```{r}
design.matrix <- as.data.frame(model.matrix(LOTT_OUTPUT))

design.matrix$Viol_crime_rate_1k_log <- plm::Within(
  d_panel_LOTT$Viol_crime_rate_1k_log)

LOTT_variables_ols <- LOTT_DF %>%
  dplyr::select(RTC_LAW,
                contains(c("White","Black","Other")),
                Unemployment_rate,
                Poverty_rate,
                Population_log,
                police_per_100k_lag) %>%
  colnames() %>%
  str_replace("RTC_LAW", "RTC_LAWTRUE") # logical class changes variable name after inital model

LOTT_fmla_ols <- as.formula(paste("Viol_crime_rate_1k_log ~",
                              paste(LOTT_variables_ols, collapse = " + ")
                              )
                        )

lm_LOTT <- lm(LOTT_fmla_ols,
             data = design.matrix)

vif(lm_LOTT)

vif_LOTT <- vif(lm_LOTT)

vif_LOTT <- vif_LOTT %>%
  as_tibble() %>%
  cbind(., names(vif_LOTT)) %>%
  as_tibble()
  
colnames(vif_LOTT) <- c("VIF", "Variable")

max_vif_LOTT <- max(vif(lm_LOTT))
```

```{r, echo=FALSE}
#This could be used to label the max VIF of each analysis

max_vif_DONOHUE
max_vif_LOTT
```

$$\frac{1}{1-R_{i}^{2}}$$

```{r}
vif_DONOHUE$Analysis <- "Analysis 1"
vif_LOTT$Analysis <- "Analysis 2"

vif_df <- rbind(vif_DONOHUE,
                vif_LOTT)

vif_plot <- vif_df %>%
  ggplot(aes(x = Analysis, y = VIF)) +
  geom_jitter(width = 0.1, alpha = 0.5, size = 2) +
  geom_hline(yintercept = 10, color = "red") +
  scale_y_continuous(trans = 'log10',
                     limits = c(1,1000)) +
  labs(title = "Variance inflation factors") + 
  theme_minimal() +
  theme(axis.title.x = element_blank())

vif_plot
```

# Synthesis

```{r, fig.height=10, echo=FALSE, message=FALSE, warning=FALSE}
title_plots <- ggdraw() + 
  draw_label(
    "Multicollinearity and its effects",
    fontface = 'bold',
    size=18,
    x = 0,
    hjust = 0
  ) +
  theme(
    plot.margin = margin(0, 0, 0, 0)
  )

forward <- ggdraw() + 
  draw_label(
    "Analysis 1: 6 demographic variables\nAnalysis 2: 36 demographic variables",
    fontface = 'bold',
    size=10,
    x = 0,
    hjust = 0
  ) +
  theme(
    plot.margin = margin(0, 0, 0, 0)
  )

corr_mat_DONOHUE <- ggcorrplot(cor_DONOHUE_dem,
                               tl.cex = 6,
                               hc.order = TRUE,
                               outline.color = "transparent",
                               colors = c("red",
                                          "white",
                                          "red"),
                            legend.title = TeX("$\\rho$")) +
  theme_void() + 
  theme(plot.title= element_text(size=8)) +
  labs(title = "Analysis 1") 

corr_mat_LOTT <- ggcorrplot(cor_LOTT_dem,
                            tl.cex = 6,
                            hc.order = TRUE,
                            outline.color = "transparent",
                            colors = c("red",
                                       "white",
                                       "red"),
                            legend.title = TeX("$\\rho$")) +
  theme_void() + 
  theme(plot.title = element_text(size=8)) +
  labs(title = "Analysis 2") 

plot_A1 <- corr_mat_DONOHUE

plot_A2 <- corr_mat_LOTT

row_A <- plot_grid(plot_A1,
                   plot_A2,
                   nrow = 1)

title_A <- ggdraw() + 
  draw_label(
    "Correlation between variables can induce multicollinearity",
    fontface = 'bold',
    size=14,
    x = 0,
    hjust = 0
  ) +
  theme(
    plot.margin = margin(0, 0, 0, 0)
  )

legend_A <- get_legend(corr_mat_LOTT)

plot_A <- plot_grid(title_A,
                    row_A,
                    ncol = 1,
                    rel_heights = c(0.1,1))

empty_df <- cbind(c(1:10),c(1:10)) %>%
  as.data.frame()

colnames(empty_df) <- c("X", "Y")

plot_B1 <- ggplot(empty_df, aes(x = X, y = Y)) +
  annotate("text",
           x=5,
           y=5,
           label = TeX("$VIF_{i} = \\frac{1}{1-R_{i}^{2}}$"),
           size = 8) +
  theme_void()

plot_B2 <- vif_plot +
  theme(axis.title.x = element_text(size=8))

row_B <- plot_grid(plot_B1,
                       plot_B2,
                       nrow = 1)

title_B <- ggdraw() + 
  draw_label(
    "Variance inflation factors can be used to identify multicollinearity when present",
    fontface = 'bold',
    size=14,
    x = 0,
    hjust = 0
  ) +
  theme(
    plot.margin = margin(0, 0, 0, 0)
  )

plot_B <- plot_grid(title_B,
                    row_B,
                    ncol = 1,
                    rel_heights = c(0.1,1))

plot_C1 <- comparing_analyses_plot + 
  theme(axis.text.x = element_text(size = 8),
        axis.title.x = element_blank()) +
  labs(title = "Introduces bias to estimates",
       subtitle = "Bias introduced can change direction of estimate")

plot_C2 <- simulation_plot +
  labs(title = "Reduces precision in estimates")

row_C <- plot_grid(plot_C1,
                       plot_C2,
                       nrow = 1)

title_C <- ggdraw() + 
  draw_label(
    "Multicollinearity can have a negative effect on statistical inference",
    fontface = 'bold',
    size=14,
    x = 0,
    hjust = 0
  ) +
  theme(
    plot.margin = margin(0, 0, 0, 0)
  )

plot_C <- plot_grid(title_C,
                    row_C,
                    ncol = 1,
                    rel_heights = c(0.1,1))

plots <- plot_grid(plot_A,
                   plot_B,
                   plot_C,
          ncol = 1,
          rel_heights = c(1,1,1))

mainplot <- plot_grid(title_plots,
                       forward,
                       plots,
                       #legend_uw,
                       ncol = 1,
                       rel_heights = c(0.05,
                                       0.05,
                                       1))

mainplot
```



```{r, echo=FALSE, include=FALSE}
ggsave(here::here("img", "mainplot.png"))
```




# **Data Visualization**
*** 

# **Summary**
*** 

# **Suggested Homework**
*** 

# **Helpful Links**
*** 

https://rpubs.com/rslbliss/fixed_effects

http://karthur.org/2019/implementing-fixed-effects-panel-models-in-r.html

https://stats.stackexchange.com/questions/99236/effects-in-panel-models-individual-time-or-twoways

